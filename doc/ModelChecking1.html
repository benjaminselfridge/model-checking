<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Model Checking in Haskell, Part 1: Transition Systems and Invariants</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../css/pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Model Checking in Haskell, Part 1: Transition Systems and Invariants</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#transition-systems">Transition systems</a>
<ul>
<li><a href="#example-traffic-light">Example: Traffic light</a></li>
<li><a href="#running-a-transition-system">Running a transition system</a></li>
</ul></li>
<li><a href="#predicates-and-propositions">Predicates and propositions</a></li>
<li><a href="#checking-invariants">Checking invariants</a>
<ul>
<li><a href="#depth-first-search">Depth-first search</a></li>
<li><a href="#the-checkinvariant-function">The <code>checkInvariant</code> function</a></li>
<li><a href="#checking-a-traffic-light-invariant">Checking a traffic light invariant</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</nav>
<p>Recently, I’ve been reading a <a href="https://www.amazon.com/Principles-Model-Checking-MIT-Press/dp/026202649X/ref=sr_1_1?crid=2RGC1B0N79HIJ&amp;keywords=principles+of+model+checking&amp;qid=1651762001&amp;sprefix=principles+of+model+checking%2Caps%2C134&amp;sr=8-1">book</a> and watching a <a href="https://www.youtube.com/watch?v=Y5Hg4MvUXc4&amp;list=PLwabKnOFhE38C0o6z_bhlF_uOUlblDTjh">lecture series</a> about model checking. This is a topic I’ve learned a bit about in the past, but never really studied in earnest.</p>
<p>In model checking, we create a <em>model</em> of some sort of stateful artifact, like a computer program, sequential circuit, or even something in the “real world” (like a vending machine or traffic light). Then, we state a <em>property</em> we would like to hold about <em>all possible behaviors</em> of the model. Finally, we check whether this property holds for the model, using a variety of nifty algorithms.</p>
<p>This series of blog posts constitutes a straightforward introduction to model checking, using Haskell code to express the ideas and implement the algorithms. The intended audience is anyone who knows a bit of Haskell, and who wants to understand what model checking is all about.</p>
<p>This post was generated with <code>pandoc</code> from a <a href="https://github.com/benjaminselfridge/model-checking/blob/master/src/ModelChecking1.lhs">literate haskell document</a>.</p>
<h1 id="overview">Overview</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ModelChecking1</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (find)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span> (<span class="dt">RandomGen</span>, randomR)</span></code></pre></div>
<p>In this post, we will introduce transition systems, and we will state simple properties about them, called <em>invariants</em>. We will also implement a simple model checking algorithm, whose aim is to check that an invariant holds for all reachable states of the system.</p>
<h1 id="transition-systems">Transition systems</h1>
<p>A <em>transition system</em> over state set <code>s</code>, action set <code>action</code>, and atomic propositions <code>ap</code> is defined as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TransitionSystem</span> s action ap <span class="ot">=</span> <span class="dt">TransitionSystem</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> tsInitialStates ::</span> [s]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsLabel         ::</span> s <span class="ot">-&gt;</span> [ap]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsTransitions   ::</span> s <span class="ot">-&gt;</span> [(action, s)]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The intuition behind each of the three fields of a transition system <code>ts</code> is as follows:</p>
<ul>
<li><code>tsInitialStates ts</code>: “the states that the system can start in”</li>
<li><code>tsLabel ts s</code>: “the set of variables which are true in state <code>s</code>”</li>
<li><code>tsTransitions ts s</code>: “all of <code>s</code>’s outgoing transitions”</li>
</ul>
<p>We interpret the label of a state <code>tsLabel ts s :: [ap]</code> as a <em>true-set</em>, or the set of all variables <code>ap</code> which are true in state <code>s</code>.</p>
<p>The label of a state is an abstraction of the “internal data” of that state, and the transitions are an abstraction of control flow. Here, a transition is a pair <code>(action, s')</code> where <code>s'</code> is the destination state of the transition, and <code>action</code> is a name for the transition.</p>
<h2 id="example-traffic-light">Example: Traffic light</h2>
<figure>
<img src="../images/traffic_light.png" style="width:30.0%;height:30.0%" alt="Transition system for a traffic light" /><figcaption aria-hidden="true">Transition system for a traffic light</figcaption>
</figure>
<p>We can create a very simple transition system representing the states and transitions of a traffic light. The states <code>s</code> will be the colors red, yellow, and green:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Yellow</span> <span class="op">|</span> <span class="dt">Green</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>There will only be one action:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Change</span> <span class="ot">=</span> <span class="dt">Change</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>Our set of transitions will allow <code>Red</code> to transition to <code>Green</code>, <code>Green</code> to <code>Yellow</code>, and <code>Yellow</code> to <code>Red</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">traffic_light ::</span> <span class="dt">TransitionSystem</span> <span class="dt">Color</span> <span class="dt">Change</span> <span class="dt">Color</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>traffic_light <span class="ot">=</span> <span class="dt">TransitionSystem</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  { tsInitialStates <span class="ot">=</span> [<span class="dt">Red</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  , tsLabel <span class="ot">=</span> \s <span class="ot">-&gt;</span> [s]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  , tsTransitions <span class="ot">=</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Red</span>    <span class="ot">-&gt;</span> [(<span class="dt">Change</span>, <span class="dt">Green</span> )]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Green</span>  <span class="ot">-&gt;</span> [(<span class="dt">Change</span>, <span class="dt">Yellow</span>)]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Yellow</span> <span class="ot">-&gt;</span> [(<span class="dt">Change</span>, <span class="dt">Red</span>   )]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Notice that we reuse our state type <code>Color</code> as our set of atomic propositions. The label of each state <code>s</code> is <code>[s]</code>: the only color that is “true” in state <code>s</code> is <code>s</code> itself.</p>
<h2 id="running-a-transition-system">Running a transition system</h2>
<p>A <em>run</em> of a transition system is a finite or infinite path in the underlying graph:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Path</span> s action <span class="ot">=</span> <span class="dt">Path</span> {<span class="ot"> pathHead ::</span> s,<span class="ot"> pathTail ::</span> [(action, s)] }</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>The following path-constructing functions will be useful:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">singletonPath ::</span> s <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>singletonPath s <span class="ot">=</span> <span class="dt">Path</span> s []</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">consPath ::</span> (s, action) <span class="ot">-&gt;</span> <span class="dt">Path</span> s action <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>consPath (s, action) (<span class="dt">Path</span> s&#39; tl) <span class="ot">=</span> <span class="dt">Path</span> s ((action, s&#39;)<span class="op">:</span>tl)</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reversePath ::</span> <span class="dt">Path</span> s action <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>reversePath (<span class="dt">Path</span> s prefix) <span class="ot">=</span> go [] s prefix</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> go suffix s [] <span class="ot">=</span> <span class="dt">Path</span> s suffix</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        go suffix s ((action, s&#39;)<span class="op">:</span>prefix) <span class="ot">=</span> go ((action, s)<span class="op">:</span>suffix) s&#39; prefix</span></code></pre></div>
<p>In the transitions systems we’ll define, it will be useful to be able to examine random infinite runs of the system to get a feel for what the possibilites are:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">randomRun ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> g <span class="ot">-&gt;</span> <span class="dt">TransitionSystem</span> s action ap <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>randomRun g ts <span class="ot">=</span> <span class="kw">let</span> (i, g&#39;) <span class="ot">=</span> randomR (<span class="dv">0</span>, <span class="fu">length</span> (tsInitialStates ts) <span class="op">-</span> <span class="dv">1</span>) g</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                     s <span class="ot">=</span> tsInitialStates ts <span class="op">!!</span> i</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> <span class="dt">Path</span> s (loop g&#39; s ts)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> loop g s ts <span class="ot">=</span> <span class="kw">let</span> nexts <span class="ot">=</span> tsTransitions ts s</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>                          (i, g&#39;) <span class="ot">=</span> randomR (<span class="dv">0</span>, <span class="fu">length</span> nexts <span class="op">-</span> <span class="dv">1</span>) g</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>                          (action, s&#39;) <span class="ot">=</span> nexts <span class="op">!!</span> i</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">in</span> (action, s&#39;) <span class="op">:</span> loop g&#39; s&#39; ts</span></code></pre></div>
<p>Let’s generate a random run of our <code>traffic_light</code> example in <code>ghci</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">System.Random</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> g <span class="ot">=</span> mkStdGen <span class="dv">0</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> r <span class="ot">=</span> randomRun g traffic_light</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> pathHead r</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Red</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">6</span> (pathTail r)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  [(<span class="dt">Change</span>,<span class="dt">Green</span>),(<span class="dt">Change</span>,<span class="dt">Yellow</span>),(<span class="dt">Change</span>,<span class="dt">Red</span>),(<span class="dt">Change</span>,<span class="dt">Green</span>),(<span class="dt">Change</span>,<span class="dt">Yellow</span>),(<span class="dt">Change</span>,<span class="dt">Red</span>)]</span></code></pre></div>
<p>Because each state in <code>traffic_light</code> has exactly one outgoing transition, this is the only run we will ever get. In subsequent posts, we’ll look at nondeterministic transition systems which will return different runs with different random generators.</p>
<h1 id="predicates-and-propositions">Predicates and propositions</h1>
<p>A <em>predicate</em> is any function that maps a value to a boolean:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Predicate</span> a <span class="ot">=</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>When working with predicates, the following “flipped application” operator is useful:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(|=) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">|=</span> p <span class="ot">=</span> p a</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">0</span> <span class="op">|=</span></span></code></pre></div>
<p>A very simple example of a predicate is <code>true</code>, which holds for all inputs:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">true ::</span> <span class="dt">Predicate</span> a</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>true _ <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>Similarly, <code>false</code> holds for no inputs:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">false ::</span> <span class="dt">Predicate</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>false _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>We can “lift” the usual boolean operators to work with predicates:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&amp;) ::</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>(p <span class="op">.&amp;</span> q) a <span class="ot">=</span> p a <span class="op">&amp;&amp;</span> q a</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">3</span> <span class="op">.&amp;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(.|) ::</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>(p <span class="op">.|</span> q) a <span class="ot">=</span> p a <span class="op">||</span> q a</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">2</span> <span class="op">.|</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="ot">pnot ::</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>pnot p a <span class="ot">=</span> <span class="fu">not</span> (p a)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="ot">(.-&gt;) ::</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>(p <span class="op">.-&gt;</span> q) a <span class="ot">=</span> <span class="kw">if</span> p a <span class="kw">then</span> q a <span class="kw">else</span> <span class="dt">True</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">1</span> <span class="op">.-&gt;</span></span></code></pre></div>
<p>A <em>proposition</em> over a set of atomic propositional variables <code>ap</code> is a predicate over true-sets of <code>ap</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Proposition</span> ap <span class="ot">=</span> <span class="dt">Predicate</span> [ap]</span></code></pre></div>
<p>Given an atomic propositional variable <code>ap</code>, we can form the proposition “<code>ap</code> holds” as follows:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atom ::</span> <span class="dt">Eq</span> ap <span class="ot">=&gt;</span> ap <span class="ot">-&gt;</span> <span class="dt">Proposition</span> ap</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>atom ap aps <span class="ot">=</span> ap <span class="ot">`elem`</span> aps</span></code></pre></div>
<p>Let’s play with propositions a bit in ghci to get a feel:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">AB</span> <span class="ot">=</span> <span class="dt">A</span> <span class="op">|</span> <span class="dt">B</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">A</span>] <span class="op">|=</span> atom <span class="dt">A</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">B</span>] <span class="op">|=</span> atom <span class="dt">A</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">A</span>, <span class="dt">B</span>] <span class="op">|=</span> atom <span class="dt">A</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">A</span>] <span class="op">|=</span> atom <span class="dt">A</span> <span class="op">.&amp;</span> atom <span class="dt">B</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">A</span>] <span class="op">|=</span> atom <span class="dt">A</span> <span class="op">.|</span> atom <span class="dt">B</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span></code></pre></div>
<h1 id="checking-invariants">Checking invariants</h1>
<p>Given a transition system <code>ts</code> and a proposition <code>p</code>, we can ask: “Does <code>p</code> hold at all reachable states in <code>ts</code>?” A proposition which is supposed to hold at all reachable states of a transition system is called an <em>invariant</em>.</p>
<p>To check whether an invariant holds, we evaluate the proposition on each reachable state (more precisely, on the <em>label</em> of each reachable state). To do this, we first define a lazy depth-first search.</p>
<h2 id="depth-first-search">Depth-first search</h2>
<p>Our search algorithm produces each reachable state, along with the path traversed to reach that state.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dfs ::</span> <span class="dt">Eq</span> s <span class="ot">=&gt;</span> [s] <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> [(action, s)]) <span class="ot">-&gt;</span> [(s, <span class="dt">Path</span> s action)]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>dfs starts transitions <span class="ot">=</span> (\p<span class="op">@</span>(<span class="dt">Path</span> s tl) <span class="ot">-&gt;</span> (s, reversePath p)) <span class="op">&lt;$&gt;</span> loop [] (singletonPath <span class="op">&lt;$&gt;</span> starts)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> loop visited stack <span class="ot">=</span> <span class="kw">case</span> stack <span class="kw">of</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>          [] <span class="ot">-&gt;</span> []</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>          ((<span class="dt">Path</span> s _)<span class="op">:</span>stack&#39;) <span class="op">|</span> s <span class="ot">`elem`</span> visited <span class="ot">-&gt;</span> loop visited stack&#39;</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>          (p<span class="op">@</span>(<span class="dt">Path</span> s _)<span class="op">:</span>stack&#39;) <span class="ot">-&gt;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> nexts <span class="ot">=</span> [ consPath (s&#39;, action) p <span class="op">|</span> (action, s&#39;) <span class="ot">&lt;-</span> transitions s ]</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">in</span> p <span class="op">:</span> loop (s<span class="op">:</span>visited) (nexts <span class="op">++</span> stack&#39;)</span></code></pre></div>
<h2 id="the-checkinvariant-function">The <code>checkInvariant</code> function</h2>
<p>Now, to check an invariant, we simply collect all the reachable states via <code>dfs</code> and make sure the invariant holds for each of their labels, producing a path to a bad state if there is one:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">checkInvariant ::</span> <span class="dt">Eq</span> s</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>               <span class="ot">=&gt;</span> <span class="dt">Proposition</span> ap</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>               <span class="ot">-&gt;</span> <span class="dt">TransitionSystem</span> s action ap</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>               <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (s, <span class="dt">Path</span> s action)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>checkInvariant p ts <span class="ot">=</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> rs <span class="ot">=</span> dfs (tsInitialStates ts) (tsTransitions ts)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> find (\(s,_) <span class="ot">-&gt;</span> tsLabel ts s <span class="op">|=</span> pnot p) rs</span></code></pre></div>
<h2 id="checking-a-traffic-light-invariant">Checking a traffic light invariant</h2>
<p>Let’s check an invariant of our traffic light system – that the light is never red and green at the same time. It’s not a very interesting invariant, but it’s a good one for any traffic light to have.</p>
<p>We can use our <code>checkInvariant</code> function to check that this invariant holds:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (pnot (atom <span class="dt">Red</span> <span class="op">.&amp;</span> atom <span class="dt">Green</span>)) traffic_light</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span></code></pre></div>
<p>The result <code>Nothing</code> means there were no counterexamples, which means our invariant holds! Let’s try it with an invariant that doesn’t hold:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (pnot (atom <span class="dt">Yellow</span>)) traffic_light</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (<span class="dt">Yellow</span>,<span class="dt">Path</span> {pathHead <span class="ot">=</span> <span class="dt">Red</span>, pathTail <span class="ot">=</span> [(<span class="dt">Change</span>,<span class="dt">Green</span>),(<span class="dt">Change</span>,<span class="dt">Yellow</span>)]})</span></code></pre></div>
<p>Our invariant checking algorithm was able to find a path to a state that violated <code>pnot (atom Yellow)</code>; unsurprisingly, the bad state was <code>Yellow</code> (the last state in the counterexample path). Because <code>Yellow</code> is reachable in our transition system, this property doesn’t hold. What if, however, <code>Yellow</code> is not reachable?</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> traffic_light <span class="ot">=</span> <span class="dt">TransitionSystem</span> [<span class="dt">Red</span>] (<span class="op">:</span>[]) (\s <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span> <span class="dt">Red</span> <span class="ot">-&gt;</span> [(<span class="dt">Change</span>, <span class="dt">Green</span>)]; <span class="dt">Green</span> <span class="ot">-&gt;</span> [(<span class="dt">Change</span>, <span class="dt">Red</span>)]; <span class="dt">Yellow</span> <span class="ot">-&gt;</span> [(<span class="dt">Change</span>, <span class="dt">Red</span>)])</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (pnot (atom <span class="dt">Yellow</span>)) traffic_light</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>Hopefully, this first post gave you a taste of what model checking is all about. In the next post, we’ll talk about how to convert higher-level programs into transition systems, we’ll explore some more interesting examples.</p>
</body>
</html>
